"""
Trading Engine

Coordinates market data, decision engine, and trade execution for each trading cycle.

Author: Trading Loop Implementation Team
Date: 2025-10-28
"""

import logging
from datetime import datetime
from decimal import Decimal
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field
from enum import Enum

# Import components
from workspace.features.market_data import MarketDataService, MarketDataSnapshot
from workspace.features.trade_executor import TradeExecutor
from workspace.features.position_manager import PositionManager


logger = logging.getLogger(__name__)


class TradingDecision(str, Enum):
    """Trading decision from decision engine"""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"


@dataclass
class TradingSignal:
    """
    Trading signal for a symbol

    Generated by decision engine based on market data analysis.

    Attributes:
        symbol: Trading pair (e.g., 'BTC/USDT:USDT')
        decision: Trading decision (BUY, SELL, HOLD, CLOSE)
        confidence: Signal confidence (0.0 to 1.0)
        size_pct: Position size as percentage of capital (0.0 to 1.0)
        stop_loss_pct: Stop-loss percentage (optional)
        take_profit_pct: Take-profit percentage (optional)
        reasoning: LLM reasoning text (optional)
        metadata: Additional signal metadata

        # Observability fields (for monitoring and cost tracking)
        model_used: LLM model that generated the signal (e.g., 'anthropic/claude-3.5-sonnet')
        tokens_input: Number of input tokens consumed
        tokens_output: Number of output tokens generated
        cost_usd: Estimated cost in USD for this signal generation
        generation_time_ms: Time taken to generate signal in milliseconds
    """

    # Core signal fields
    symbol: str
    decision: TradingDecision
    confidence: Decimal  # 0.0 to 1.0
    size_pct: Decimal  # Percentage of available capital (0.0 to 1.0)
    stop_loss_pct: Optional[Decimal] = None  # Stop-loss percentage (e.g., 0.02 for 2%)
    take_profit_pct: Optional[Decimal] = None  # Take-profit percentage
    reasoning: Optional[str] = None  # LLM reasoning text

    # Observability fields (added for production monitoring)
    model_used: Optional[str] = None  # LLM model identifier
    tokens_input: Optional[int] = None  # Input tokens consumed
    tokens_output: Optional[int] = None  # Output tokens generated
    cost_usd: Optional[Decimal] = None  # Estimated cost in USD
    generation_time_ms: Optional[int] = None  # Generation time in milliseconds

    # Additional metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """Validate signal parameters"""
        if not 0 <= self.confidence <= 1:
            raise ValueError(f"Confidence must be 0-1, got {self.confidence}")
        if not 0 <= self.size_pct <= 1:
            raise ValueError(f"Size percentage must be 0-1, got {self.size_pct}")

    def get_estimated_monthly_cost(self, signals_per_day: int = 480) -> Decimal:
        """
        Calculate estimated monthly cost for this signal type

        Args:
            signals_per_day: Number of signals generated per day (default: 480 = 6 symbols * 80 cycles/day)

        Returns:
            Estimated monthly cost in USD
        """
        if not self.cost_usd:
            return Decimal("0")

        signals_per_month = signals_per_day * 30
        return self.cost_usd * Decimal(str(signals_per_month))


@dataclass
class TradingCycleResult:
    """
    Result of a complete trading cycle

    Contains all information about market data, decisions, and execution results.
    """

    cycle_number: int
    timestamp: datetime
    symbols: List[str]

    # Market data
    snapshots: Dict[str, MarketDataSnapshot]  # symbol -> snapshot

    # Decisions
    signals: Dict[str, TradingSignal]  # symbol -> signal

    # Execution
    orders_placed: int = 0
    orders_filled: int = 0
    orders_failed: int = 0

    # Performance
    duration_seconds: float = 0.0
    errors: List[str] = field(default_factory=list)

    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def success(self) -> bool:
        """Check if cycle completed successfully (no critical errors)"""
        return len(self.errors) == 0

    def to_dict(self) -> dict:
        """Convert to dictionary for logging/storage"""
        return {
            "cycle_number": self.cycle_number,
            "timestamp": self.timestamp.isoformat(),
            "symbols": self.symbols,
            "snapshots_count": len(self.snapshots),
            "signals_count": len(self.signals),
            "orders_placed": self.orders_placed,
            "orders_filled": self.orders_filled,
            "orders_failed": self.orders_failed,
            "duration_seconds": self.duration_seconds,
            "errors_count": len(self.errors),
            "success": self.success,
        }


class TradingEngine:
    """
    Trading Engine

    Coordinates all components to execute complete trading cycles:
    1. Fetch market data snapshots
    2. Generate trading signals (via decision engine)
    3. Execute trades
    4. Update positions and risk management

    Features:
    - Multi-symbol coordination
    - Error handling and recovery
    - Performance tracking
    - Decision engine integration (LLM)
    - Trade execution with risk management

    Attributes:
        market_data_service: Market data provider
        trade_executor: Trade execution service
        position_manager: Position tracking
        symbols: List of trading pairs to manage

    Example:
        ```python
        engine = TradingEngine(
            market_data_service=market_data,
            trade_executor=executor,
            position_manager=positions,
            symbols=['BTCUSDT', 'ETHUSDT'],
        )

        result = await engine.execute_trading_cycle(cycle_number=1)
        print(f"Cycle complete: {result.success}")
        ```
    """

    def __init__(
        self,
        market_data_service: MarketDataService,
        trade_executor: TradeExecutor,
        position_manager: PositionManager,
        symbols: List[str],
        decision_engine: Optional[Any] = None,  # To be implemented in TASK-008
    ):
        """
        Initialize Trading Engine

        Args:
            market_data_service: Market data service instance
            trade_executor: Trade executor instance
            position_manager: Position manager instance
            symbols: List of trading pairs
            decision_engine: Decision engine instance (optional, for TASK-008)
        """
        self.market_data_service = market_data_service
        self.trade_executor = trade_executor
        self.position_manager = position_manager
        self.symbols = symbols
        self.decision_engine = decision_engine

        # State
        self.cycle_count = 0
        self.total_orders = 0
        self.total_errors = 0

    async def execute_trading_cycle(self, cycle_number: int) -> TradingCycleResult:
        """
        Execute complete trading cycle

        Steps:
        1. Fetch market data snapshots for all symbols
        2. Generate trading signals (via decision engine)
        3. Execute trades based on signals
        4. Update positions and risk management

        Args:
            cycle_number: Current cycle number

        Returns:
            TradingCycleResult with complete cycle information

        Raises:
            Exception: If critical error occurs during cycle
        """
        start_time = datetime.utcnow()
        logger.info(f"Executing trading cycle #{cycle_number}")

        result = TradingCycleResult(
            cycle_number=cycle_number,
            timestamp=start_time,
            symbols=self.symbols,
            snapshots={},
            signals={},
        )

        try:
            # Step 1: Fetch market data snapshots
            logger.info("Step 1: Fetching market data snapshots")
            result.snapshots = await self._fetch_market_data_snapshots()
            logger.info(f"Fetched {len(result.snapshots)} snapshots")

            # Step 2: Generate trading signals
            logger.info("Step 2: Generating trading signals")
            result.signals = await self._generate_trading_signals(result.snapshots)
            logger.info(f"Generated {len(result.signals)} signals")

            # Step 3: Execute trades
            logger.info("Step 3: Executing trades")
            execution_results = await self._execute_trades(result.signals)
            result.orders_placed = execution_results["orders_placed"]
            result.orders_filled = execution_results["orders_filled"]
            result.orders_failed = execution_results["orders_failed"]
            logger.info(
                f"Execution complete: {result.orders_placed} placed, "
                f"{result.orders_filled} filled, {result.orders_failed} failed"
            )

            # Step 4: Update metrics
            self.cycle_count += 1
            self.total_orders += result.orders_placed

        except Exception as e:
            error_msg = f"Trading cycle #{cycle_number} failed: {e}"
            logger.error(error_msg, exc_info=True)
            result.errors.append(error_msg)
            self.total_errors += 1

        finally:
            # Calculate duration
            result.duration_seconds = (datetime.utcnow() - start_time).total_seconds()
            logger.info(
                f"Trading cycle #{cycle_number} complete in {result.duration_seconds:.2f}s "
                f"(success: {result.success})"
            )

        return result

    async def _fetch_market_data_snapshots(self) -> Dict[str, MarketDataSnapshot]:
        """
        Fetch market data snapshots for all symbols

        Returns:
            Dictionary mapping symbol to MarketDataSnapshot

        Note: Symbols without valid snapshots are excluded from result
        """
        snapshots = {}

        for symbol in self.symbols:
            try:
                snapshot = await self.market_data_service.get_snapshot(symbol)

                if snapshot is None:
                    logger.warning(f"No snapshot available for {symbol}")
                    continue

                if not snapshot.has_all_indicators:
                    logger.warning(f"Incomplete indicators for {symbol}")
                    continue

                snapshots[symbol] = snapshot
                logger.debug(f"Snapshot fetched: {symbol} @ {snapshot.ohlcv.close}")

            except Exception as e:
                logger.error(
                    f"Error fetching snapshot for {symbol}: {e}", exc_info=True
                )

        return snapshots

    async def _generate_trading_signals(
        self,
        snapshots: Dict[str, MarketDataSnapshot],
    ) -> Dict[str, TradingSignal]:
        """
        Generate trading signals based on market data

        This method will integrate with the Decision Engine (TASK-008).
        For now, it returns a placeholder HOLD signal.

        Args:
            snapshots: Market data snapshots for all symbols

        Returns:
            Dictionary mapping symbol to TradingSignal
        """
        signals = {}

        if self.decision_engine:
            # Use decision engine (TASK-008)
            logger.info("Using decision engine for signal generation")
            signals = await self.decision_engine.generate_signals(snapshots)

        else:
            # Placeholder: Generate HOLD signals for all symbols
            logger.debug("No decision engine configured, generating HOLD signals")

            for symbol, snapshot in snapshots.items():
                signal = TradingSignal(
                    symbol=symbol,
                    decision=TradingDecision.HOLD,
                    confidence=Decimal("0.5"),
                    size_pct=Decimal("0.0"),
                    reasoning="Placeholder signal - decision engine not configured",
                )
                signals[symbol] = signal

        return signals

    async def _execute_trades(
        self,
        signals: Dict[str, TradingSignal],
    ) -> Dict[str, int]:
        """
        Execute trades based on trading signals

        Args:
            signals: Trading signals for each symbol

        Returns:
            Dictionary with execution statistics:
            - orders_placed: Number of orders placed
            - orders_filled: Number of orders filled
            - orders_failed: Number of orders failed
        """
        stats = {
            "orders_placed": 0,
            "orders_filled": 0,
            "orders_failed": 0,
        }

        for symbol, signal in signals.items():
            try:
                # Skip HOLD signals
                if signal.decision == TradingDecision.HOLD:
                    logger.debug(f"Skipping {symbol} (HOLD signal)")
                    continue

                # Execute signal
                await self._execute_signal(symbol, signal, stats)

            except Exception as e:
                logger.error(f"Error executing signal for {symbol}: {e}", exc_info=True)
                stats["orders_failed"] += 1

        return stats

    async def _execute_signal(
        self,
        symbol: str,
        signal: TradingSignal,
        stats: Dict[str, int],
    ):
        """
        Execute a single trading signal

        Args:
            symbol: Trading pair
            signal: Trading signal
            stats: Statistics dictionary to update
        """
        logger.info(
            f"Signal: {symbol} | {signal.decision.value.upper()} | "
            f"Confidence: {signal.confidence} | Size: {signal.size_pct}"
        )

        if signal.reasoning:
            logger.debug(f"Reasoning: {signal.reasoning}")

        try:
            # Get account balance from exchange (real-time with 60s caching)
            account_balance_chf = await self.trade_executor.get_account_balance()
            # TODO: In production, fetch real-time CHF/USD rate from forex API
            chf_to_usd_rate = Decimal("1.10")

            # Execute the signal via TradeExecutor
            result = await self.trade_executor.execute_signal(
                signal=signal,
                account_balance_chf=account_balance_chf,
                chf_to_usd_rate=chf_to_usd_rate,
                risk_manager=None,  # TODO: Add risk manager integration
            )

            # Update stats based on result
            if result.success:
                stats["orders_placed"] += 1
                logger.info(
                    f"Successfully executed {signal.decision.value} signal for {symbol} "
                    f"(latency: {result.latency_ms}ms)"
                )
                if result.order:
                    logger.debug(
                        f"Order ID: {result.order.exchange_order_id}, "
                        f"Status: {result.order.status.value}"
                    )
            else:
                stats["orders_failed"] += 1
                logger.warning(
                    f"Failed to execute signal for {symbol}: "
                    f"{result.error_code} - {result.error_message}"
                )

        except Exception as e:
            stats["orders_failed"] += 1
            logger.error(f"Error executing signal for {symbol}: {e}", exc_info=True)

    def get_status(self) -> dict:
        """
        Get trading engine status

        Returns:
            Dictionary with engine metrics
        """
        return {
            "cycle_count": self.cycle_count,
            "total_orders": self.total_orders,
            "total_errors": self.total_errors,
            "symbols": self.symbols,
            "has_decision_engine": self.decision_engine is not None,
        }


# Export
__all__ = [
    "TradingEngine",
    "TradingDecision",
    "TradingSignal",
    "TradingCycleResult",
]
